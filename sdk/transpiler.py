import re
import dis
import textwrap
from types import CodeType

from .util import error

class TranslationUnit:
    """
    Represents a single translation unit, which contains C function bodies that
    represent Python code fragments (e.g. module-level code, functions, methods, etc.)
    """

    def __init__(self):
        self.transpiled: dict[str, str] = {}
        "Stores mappings between mangled function names and their C function bodies."

    def mangle(self, fn: CodeType):
        return "pyfn__" + re.sub(r"[^_A-Za-z0-9]", "__", fn.co_qualname)

    def translate(self, fn: CodeType):
        """
        Transpiles the given code fragment into a C function, returning its mangled name.
        The function itself can be retrieved via `self.transpiled`. If the function was already
        transpiled before, this function does nothing.
        """
        mangled_name = self.mangle(fn)
        if mangled_name in self.transpiled:
            return mangled_name

        defined_preprocessor_syms = []

        constants = ""
        for i, const in enumerate(fn.co_consts):
            if type(const) is str:
                constants += f'static const pyobj_t const_{i} = {{ .type = &py_type_str, .as_str = "{const}" }};\n'
            elif type(const) is int:
                constants += f"static const pyobj_t const_{i} = {{ .type = &py_type_int, .as_int = {const} }};\n"
            elif type(const) is float:
                constants += f"static const pyobj_t const_{i} = {{ .type = &py_type_float, .as_float = {const} }};\n"
            elif type(const) is bool:
                constants += f"#define const_{i} (py_true)\n" if const else f"#define const_{i} (py_false)\n"
                defined_preprocessor_syms.append(f"const_{i}")
            elif type(const).__name__ == "code":
                # If we have a 'code' constant, this means that this is a callable.
                code: CodeType = const
                target_fn = self.translate(code)
                constants += f"static const pyobj_t const_{i} = {{ .type = &py_type_callable, .as_callable = &{target_fn} }};\n"
            elif const is None:
                constants += f"#define const_{i} (py_none)\n"
                defined_preprocessor_syms.append(f"const_{i}")
            else:
                error(f"unknown constant type '{type(const).__name__}'!")
                error(f"the value of the constant is {const}")
                raise Exception(f"Unknown constant type: {type(const).__name__}")
            
        body = [
            f"// Function {fn.co_qualname}, declared on line {fn.co_firstlineno}"
            f"void* stack[{fn.co_stacksize + 1}];"
            f"int stack_current = -1;",
            ""
        ]

        bytecode = dis.Bytecode(fn)
        for instr in bytecode:
            body.append(f"// {instr._disassemble(offset_width = 0).strip()}")

            match instr.opname:
                case "RESUME":
                    pass # no-op
                case "PUSH_NULL":
                    body.append("stack[stack_current++] = NULL;")
                case "LOAD_NAME":
                    name = fn.co_names[instr.arg]
                    body.append(f'stack[stack_current++] = py_resolve_symbol("{name}");')
                case "LOAD_CONST":
                    const = fn.co_consts[instr.arg]
                    body.append(f"stack[stack_current++] = &const_{i};");
                case "CALL":
                    body.append(f"PY_OPCODE_CALL({instr.arg});")
                case "POP_TOP":
                    body.append(f"stack_current--;")
                case "RETURN_CONST":
                    body.append(f"return &const_{i};")
                case _:
                    error(f"unknown opcode '{instr.opname}'!")
                    error(f"offending instruction: {instr._disassemble(offset_width = 0).strip()}")
                    error(f"the full disassembly of the target function is displayed below")
                    print(dis.dis(fn))
                    raise Exception(f"Unknown opcode: {instr.opname}")

        body.append()
        body.append("// (function end)")
        body.append()

        for sym in defined_preprocessor_syms:
            body.append(f"#undef {sym}")

        self.transpiled[mangled_name] = "\n".join(body)
        return mangled_name

    def transpile(self):
        "Merges all compiled functions into one C file."
        lines: list[str] = []

        lines.append("// <auto-generated>")
        lines.append("// This code was transpiled from Python code by POSOS.")
        lines.append("// </auto-generated>")
        lines.append("")
        lines.append('#include "runtime/all.h"')
        lines.append("")

        lines.append("// Transpiled function declarations")
        for fn_name in self.transpiled.keys():
            lines.append(f"PY_DEFINE({fn_name});")

        lines.append("")
        lines.append("// Transpiled function implementations")
        for fn_name, fn_body in self.transpiled.items():
            lines.append("PY_DEFINE(" + fn_name + ") {")
            lines.append(textwrap.indent(fn_body, "    "))
            lines.append("}")
            lines.append()

        return "\n".join(lines)
    